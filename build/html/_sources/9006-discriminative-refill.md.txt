
# 9006: 语言模型内容填充

- 不使用的后果: 目前不明确,是一个模型实验性的一部分

- 具体形式:

给定token序列并 $x_{ik}$, 抽取若干token构成无序的内容集合并在抽取位填入mask token.

  $$
  \left\{
  \begin{align}
  Y&=\{y_{jk}\} \\
  z_{ik}&=\text{mask} \  \text{if} 
  \  i \in \{j\} \\
        &=x_{ik} \ \text{elsewise}
  \end{align}
  \right.
  $$

- 损失形式:

$$
\begin{align}
L &= \sum_{i} x_{ik} \log f_{ik}(Y,Z) \\
f_{i+1,k}(Y,Z) &= \text{choose a token to output given the current grammar}
\end{align}
$$

- 需要使用一个迭代的方法来计算f,回答如下问题
- 我当前处于什么状态 状态更新
- 我要输出何种信息 信息输出
- 信息输出:可以抽象为选择提取矩阵,然后从信息向量中提取.特别的,KV提取是一类特殊的提取矩阵和信息向量.
- 状态更新:可以抽象为做一个梯度操作,使得某个提取矩阵的输出等于目标输出.

- 信息输出: 考虑基于KVC的多元状态向量,令K为C的投影.信息输出可以抽象为先从状态中提取提取Query向量,然后和K
再输出....好像多此一举?直接用一个外部Query提取一个向量输出就完事了?

  - 但是模型需要区分应该从哪条输入线,先假设不使用KV提取的情况下,选择权下放给一个配合SlotMemory的选择器
  这个选择器可以进行有限个选择,但是SlotMemory对permute就不是不变的了.

  - 现在假设Memory还是以KV形式存在,但是模型需要根据状态来选择Query,又或者说,记忆和控制序列是混在
  KV矩阵里面的,KV既需要接受浅层Query提取,又要生成Query本身,也就是说,我们要求从KV进行的输出的这个
  提取操作,最后一步必须是简单的Query提取,把剩下的复杂度留给生成Query的这个过程.

  - 最简单的Query生成就是用一个外部固定Query1对Memory进行提取生成一个Query2,然后Query2再对
  KV容器进行提取.
  - 也可以用多几个Query来增强一下定位效果
  - 复杂一点的Query生成可能需要考虑到二阶项,也就是需要考虑KV容器内部的向量的相互作用状态,
  可以试着挂一层self-attention上去试试看.
  - 如果运用粒子化思想,那么简单的query就是根据空间来提取信息,加了SA的就是允许系统在多体相互作用下运行
  若干步再进行特定空间的提取. 如果要倒过来继续保持Query2简单提取的方式,那就要把Query2作为多体的一部分
  倒过来运行一下多体相互作用, 或者就是简单地仅仅允许Query2单独进行动力学.

- 状态更新:
  - 如果希望特定投影满足约束,可以考虑新添加粒子,或者移动原有粒子.
  - 目前仅进行粒子移动操作
  - 也可以考虑多体作用,但是会降低可解释性




继承输出,先假设这个是最终的提取Query可以用一个简单的选择器,这个选择器表征自己需要的是
